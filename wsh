#!/usr/bin/env bash
#set -euo pipefail
IFS=$'\t\n'

help_format="  %-3s %-20s %s\n"
help_format_1="  $help_format"
wsh_dir=$(dirname $(realpath "$0"))
plugin_dir="$wsh_dir/plugins"
shim_dir="$wsh_dir/shims"

# FLAGS
## GLOBAL
debug=
## INIT
init=
init_pyenv=
init_nvm=
init_uninit=
##SHELL
shell_sync=
##TIME
time=

# ARGS
## SHELL
shell_args=()
## TIME
time_from_arg=
time_start_arg=

# LIBS
source "$wsh_dir/_utils.sh"
source "$wsh_dir/_time.sh"

print_option() {
    local level="$1"
    local short="$2"
    local long="$3"
    local arg="$4"
    local desc="$5"

    local indent="  "
    for ((i = 0; i < level; i++)); do
        indent="  $indent"
    done

    if [[ -n "$arg" ]]; then
        printf "${indent}%-3s %-20s %s\n" "$short" "$long <$arg>" "$desc"
    else
        printf "${indent}%-3s %-20s %s\n" "$short" "$long" "$desc"
    fi
}

usage() {
    log ""
    log "usage: $(basename $0) OPERATION [...]"
    log ""
    log "some OPTIONS enter a context and will allow the use of more OPTIONS, but whenever an OPTION from outside this context is passed, then it leaves the context, meaning that the order of OPTIONS is semi-important"
    log "examples:"
    log " wsh -Ipv"
    log " wsh -vIp"
    log ""
    log "bad examples:"
    log " wsh -Ivp # -v breaks the -I context, making -p no longer relevant"
    log ""
    print_option 0 "-h" "--help" "" "show this menu"
    print_option 0 "-v" "--vebose" "" "extensive logging"
    print_option 0 "-I" "--init" "" "init options"
    print_option 1 "-n" "--nvm" "" "init nvm"
    print_option 1 "-p" "--pyenv" "" "init pyenv"
    print_option 1 "-u" "--uninit" "" "instead of initializing, uninitialize relevant init scripts"
    # TODO
    print_option 0 "-S" "--shell" "" "shell options"
    print_option 1 "-S" "--sync" "" "sync a package, which will install or update a package"
    # TODO END
    print_option 0 "-T" "--time" "" "time tracker options"
    print_option 1 "-o" "--offline" "" "do not query the server for time; REQUIRES --start"
    print_option 1 "-f" "--from" "days" "from how many days ago to calculate overtime"
    print_option 1 "-s" "--start" "timestamp" "override shift start time and don't query the server for this info; REQUIRED when --offline"
}

pre_process_flags() {
    for arg in "$@"; do
        case "$arg" in
        --*)
            stdout "$arg"
            ;;
        -*)
            for ((i = 1; i < ${#arg}; i++)); do
                stdout "-${arg:i:1}"
            done
            ;;
        *)
            stdout "$arg"
            ;;
        esac
    done
}

unknown_flag() {
    error "unknown argument: $1"
    log "mayhaps it was used in the wrong context?"
    usage
    exit 1
}

no_arg_for_flag() {
    error "$1 requires an argument $2"
    usage
    exit 1
}

validate_time_from() {
    if [[ ! "$1" =~ ^[0-9]+$ ]] || [[ "$1" -lt 1 ]]; then
        error "days must be a positive integer, not $1"
        exit 1
    fi
}

validate_time_start() {
    if [[ ! "$1" =~ ^([0-9]|[0-1][0-9]|2[0-4]):([0-9]|[0-5][0-9])$ ]]; then
        error "timestamp must be in format of H:M, HH:MM and their permutations, not $1"
        exit 1
    fi
}

count_ops() {
    local -a arr_name=$1
    shift
    local -a temp
    count=0
    for op in "$@"; do
        if [[ ${!op} ]]; then
            ((count++))
            temp+=("$op")
        fi
    done
    eval "$arr_name=(\"\${temp[@]}\")"
    return $count
}

setup_shims() {
    local shim_content="$1"
    shift
    mkdir -p "$shim_dir"

    for shim in "$@"; do
        if [[ -n $init_uninit ]]; then
            rm -f "$shim_dir/$shim"
        else
            echo "#!/usr/bin/env bash
cmd=\"\$(which -a \$(basename \"\$0\") | grep -v \"\$(realpath \"\$0\")\" | head -1)\" 
if [[ -z \"\$cmd\" ]]; then
    $shim_content
fi
exec \"\$cmd\" \"\$@\"" > "$shim_dir/$shim"
            chmod +x "$shim_dir/$shim"
        fi
    done
}

if [[ ${#@} -eq 0 ]]; then
    usage
    exit 1
fi
to_array flags "$(pre_process_flags "$@")"

for ((i = 0; i < "${#flags[@]}"; i++)); do
    case "${flags[$i]}" in
    --help | -h)
        usage
        exit 0
        ;;
    --verbose | -v)
        debug=1
        ;;
    --init | -I)
        init=1
        ((i++)) || true
        for (( ; i < "${#flags[@]}"; i++)); do
            case "${flags[$i]}" in
            --pyenv | -p)
                init_pyenv=1
                ;;
            --nvm | -n)
                init_nvm=1
                ;;
            --uninit | -u)
                init_uninit=1
                ;;
            *)
                ((i--)) || true
                break
                ;;
            esac
        done
        ;;
    --shell | -S)
        ((i++)) || true
        for (( ; i < "${#flags[@]}"; i++)); do
            case "${flags[$i]}" in
            --sync | -S)
                shell_sync=1
                ;;
            --* | -*)
                ((i--)) || true
                break
                ;;
            *)
                shell_args+=("${flags[$i]}")
                ;;
            esac
        done
        ;;
    --time | -T)
        time=1
        ((i++)) || true
        for (( ; i < "${#flags[@]}"; i++)); do
            case "${flags[$i]}" in
            --offline | -o)
                time_offline=1
                ;;
            --from | -f)
                time_from=1
                if [[ $((i + 1)) -lt "${#flags[@]}" ]]; then
                    ((i++))
                    time_from_arg="${flags[$i]}"
                    validate_time_from "$time_from_arg"
                else 
                    no_arg_for_flag "${flags[$i]}" "days"
                fi
                ;;
            --start | -s)
                time_start=1
                if [[ $((i + 1)) -lt "${#flags[@]}" ]]; then
                    ((i++))
                    time_start_arg="${flags[$i]}"
                    validate_time_start "$time_start_arg"
                else 
                    no_arg_for_flag "${flags[$i]}" "timestamp"
                fi
                ;;
            *)
                ((i--)) || true
                break
                ;;
            esac
        done
        ;;
    *)
        unknown_flag "${flags[i]}"
        ;;
    esac
done

# ADD MORE OPS HERE
count_ops ops init shell_sync time
op_count=$?

if [[ $op_count -eq 0 ]]; then
    log "no operation defined"
    usage
    exit 1
elif [[ $op_count -gt 1 ]]; then
    log "more than 1 operation defined: " "${ops[@]}"
    usage
    exit 1
fi

if [[ -z $init ]]; then
    debug "initializing autocompletions"
    echo "autoload -Uz compinit"
    echo "compinit"
    echo "eval $(starship init zsh)"
    echo "PATH=\"$shim_dir:\$PATH\""
fi

if [[ -n $init_pyenv ]]; then
    debug "initializing pyenv"
    setup_shims \
    'export PYENV_ROOT="$HOME/.pyenv"
    [[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
    eval "$(command pyenv init - zsh)"' \
    pyenv python python3 pip pip3
fi

if [[ -n $init_nvm ]]; then
    debug "initializing nvm"
    setup_shims \
    'export NVM_DIR="$HOME/.nvm"
    [ -s "/opt/homebrew/opt/nvm/nvm.sh" ] && \. "/opt/homebrew/opt/nvm/nvm.sh"  # This loads nvm
    [ -s "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm" ] && \. "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm"' \
    nvm node npm npx pnpm
fi

if [[ -n $shell_sync ]]; then
    debug "syncing packages"
    for pkg in "${args[@]}"; do
        echo $pkg
    done
fi

if [[ -n $time ]]; then
    debug "yay"
    solidtime_get "/users/me/memberships"
fi
